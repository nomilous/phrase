#
# phrase graph
# ============
#
# Container to house all vertexes and edges of the phrase tree
# that is assembled by the phrase recursor's 'first walk'
# 

exports.create = (root) -> 

    vertices = {}
    edges    = {}

    #
    # special case for trees
    # ----------------------
    # 
    # ### parent
    # 
    # Index maps vertex to parent vertex 
    # ie. parent[ UUID ] = parentUUID
    # 
    # ### children
    # 
    # Index maps vertex to array of children, (in created order)
    # children[ UUID ] = [child1UUID, child2UUID, ...]
    # 
    # ### leaves
    # 
    # Array of vertexes that are leaves on the tree
    # 
    # ### tree
    # 
    # tree.leaves - Leaf list with path from root
    # 

    parent   = {} 
    children = {}
    leaves   = []
    tree     = leaves: {}

    api = 

        #
        # assembler(msg, next)
        # --------------------
        # 
        # Middleware assembles the phrase graph from 'phrase::edge:create'
        # messages generated by the 'first walk'
        #

        assembler: (msg, next) -> 

            # console.log msg.content

            if msg.context.title == 'phrase::edge:create'

                api.registerEdge msg, next
            
            else if msg.context.title == 'phrase::leaf:create'

                api.registerLeaf msg, next

            else next()

        registerEdge: (msg, next) -> 

            [vertex1, vertex2] = msg.vertices

            #
            # the edge emitter includes [root, undefined]
            # ignore it
            #

            return next() unless vertex2

            #
            # TODO: overrwrite / change detection / related event generation
            #

            vertices[vertex1.uuid] = vertex1
            vertices[vertex2.uuid] = vertex2

            #
            # TODO: non tree edges / weight / direction / etcetera
            #

            edges[ vertex1.uuid ] ||= []
            edges[ vertex1.uuid ].push connect: vertex2.uuid

            edges[ vertex2.uuid ] ||= []
            edges[ vertex2.uuid ].push connect: vertex1.uuid

            if msg.type == 'tree'

                parent[ vertex2.uuid ] = vertex1.uuid
                children[ vertex1.uuid ] ||= []
                children[ vertex1.uuid ].push vertex2.uuid
                leaves.push vertex2.uuid if vertex2.leaf

            next()

        registerLeaf: (msg, next) -> 

            tree.leaves[msg.uuid] = msg
            next()


    Object.defineProperty api, 'vertices', 

        enumerable: true
        get: -> vertices

    Object.defineProperty api, 'edges', 

        enumerable: true
        get: -> edges

    Object.defineProperty api, 'parent', 

        enumerable: true
        get: -> parent

    Object.defineProperty api, 'children', 

        enumerable: true
        get: -> children

    Object.defineProperty api, 'leaves', 

        enumerable: true
        get: -> leaves

    Object.defineProperty api, 'tree', 

        enumerable: true
        get: -> tree

    





