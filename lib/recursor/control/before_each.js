// Generated by CoffeeScript 1.6.3
var BoundryTokenFactory, LeafTokenFactory, RootTokenFactory, VertexTokenFactory, sequence, v1;

sequence = require('when/sequence');

RootTokenFactory = require('../../token/root_token');

VertexTokenFactory = require('../../token/vertex_token');

LeafTokenFactory = require('../../token/leaf_token');

BoundryTokenFactory = require('../../token/boundry_token');

v1 = require('node-uuid').v1;

exports.create = function(root, parentControl) {
  var PhraseNode, context, notice, stack, tokenTypes, util;
  context = root.context, util = root.util;
  stack = context.stack, notice = context.notice, PhraseNode = context.PhraseNode;
  tokenTypes = {
    root: RootTokenFactory.createClass(root),
    vertex: VertexTokenFactory.createClass(root),
    leaf: LeafTokenFactory.createClass(root),
    boundry: BoundryTokenFactory.createClass(root)
  };
  return function(done, injectionControl) {
    var deferral, error, phrase, phraseControl, phraseFn, phraseText, phraseToken, phraseType, run, uuid;
    deferral = injectionControl.defer;
    phraseText = typeof injectionControl.args[0] === 'function' ? '' : injectionControl.args[0];
    phraseControl = typeof injectionControl.args[1] === 'function' ? {} : injectionControl.args[1];
    phraseFn = injectionControl.args[2] || injectionControl.args[1] || injectionControl.args[0] || function() {
      return console.log('NO ARGS');
    };
    phraseControl || (phraseControl = {});
    phraseControl.leaf || (phraseControl.leaf = parentControl.leaf);
    phraseControl.boundry || (phraseControl.boundry = parentControl.boundry);
    phraseControl.timeout || (phraseControl.timeout = parentControl.timeout);
    injectionControl.args[0] = phraseText;
    injectionControl.args[1] = phraseControl;
    injectionControl.args[2] = phraseFn;
    try {
      if (phraseControl != null) {
        phraseControl.phraseToken = {
          signature: util.argsOf(phraseFn)[0]
        };
      }
      phraseType = parentControl.phraseType(phraseFn);
      if (stack.length === 0) {
        phraseType = 'root';
        uuid = parentControl.phraseToken.uuid;
      } else {
        uuid = phraseControl.uuid;
      }
      phraseToken = new tokenTypes[phraseType]({
        uuid: uuid || v1(),
        signature: parentControl.phraseToken.signature
      });
      stack.push(phrase = new PhraseNode({
        text: phraseText,
        token: phraseToken,
        uuid: uuid,
        leaf: phraseType === 'leaf',
        timeout: phraseControl.timeout,
        hooks: {
          beforeAll: injectionControl.beforeAll,
          beforeEach: injectionControl.beforeEach,
          afterEach: injectionControl.afterEach,
          afterAll: injectionControl.afterAll
        },
        fn: phraseFn,
        deferral: deferral,
        queue: injectionControl.queue
      }));
    } catch (_error) {
      error = _error;
      done(error);
    }
    if (phraseType === 'leaf') {
      injectionControl.args[2] = function() {};
    }
    run = sequence([
      function() {
        return notice.event('phrase::edge:create', {
          type: 'tree',
          vertices: stack.slice(-2)
        });
      }
    ]);
    return run.then(function() {
      var result;
      done();
      if (phraseType === 'leaf') {
        process.nextTick(function() {
          return deferral.resolve();
        });
      }
      if (phraseType === 'boundry') {
        result = phrase.fn(function() {});
        return deferral.resolve();
      }
    });
  };
};
