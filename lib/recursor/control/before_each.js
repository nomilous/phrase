// Generated by CoffeeScript 1.6.3
var BoundryHandler, PhraseTokenFactory, pipeline, sequence;

sequence = require('when/sequence');

pipeline = require('when/pipeline');

PhraseTokenFactory = require('../../token/phrase_token');

BoundryHandler = require('../boundry_handler');

exports.create = function(root, parentControl) {
  var PhraseNode, PhraseToken, context, notice, stack, util;
  context = root.context, util = root.util;
  stack = context.stack, notice = context.notice, PhraseNode = context.PhraseNode, PhraseToken = context.PhraseToken;
  return function(done, injectionControl) {
    var actualPhraseType, deferral, error, phrase, phraseControl, phraseFn, phraseTitle, phraseToken, phraseType, run, uuid;
    deferral = injectionControl.defer;
    phraseTitle = typeof injectionControl.args[0] === 'function' ? '' : injectionControl.args[0];
    phraseControl = typeof injectionControl.args[1] === 'function' ? {} : injectionControl.args[1];
    phraseFn = injectionControl.args[2] || injectionControl.args[1] || injectionControl.args[0] || function() {
      return console.log('NO ARGS');
    };
    phraseControl || (phraseControl = {});
    phraseControl.leaf || (phraseControl.leaf = parentControl.leaf);
    phraseControl.boundry || (phraseControl.boundry = parentControl.boundry);
    phraseControl.timeout || (phraseControl.timeout = parentControl.timeout);
    injectionControl.args[0] = phraseTitle;
    injectionControl.args[1] = phraseControl;
    injectionControl.args[2] = phraseFn;
    try {
      if (phraseControl != null) {
        phraseControl.phraseToken = {
          signature: util.argsOf(phraseFn)[0]
        };
      }
      phraseType = actualPhraseType = parentControl.phraseType(phraseFn);
      if (stack.length === 0) {
        phraseType = 'root';
        uuid = parentControl.phraseToken.uuid;
      } else {
        uuid = phraseControl.uuid;
      }
      phraseToken = new PhraseToken({
        type: phraseType,
        uuid: uuid || util.uuid(),
        signature: parentControl.phraseToken.signature
      });
      stack.push(phrase = new PhraseNode({
        title: phraseTitle,
        token: phraseToken,
        uuid: phraseToken.uuid,
        timeout: phraseControl.timeout,
        hooks: {
          beforeAll: injectionControl.beforeAll,
          beforeEach: injectionControl.beforeEach,
          afterEach: injectionControl.afterEach,
          afterAll: injectionControl.afterAll
        },
        fn: phraseFn,
        deferral: deferral,
        queue: injectionControl.queue
      }));
    } catch (_error) {
      error = _error;
      return done(error);
    }
    if (phraseType === 'leaf') {
      injectionControl.args[2] = function() {};
    }
    run = sequence([
      function() {
        return notice.event('phrase::edge:create', {
          vertices: stack.slice(-2),
          root: {
            uuid: root.uuid
          }
        });
      }
    ]);
    return run.then(function() {
      var linkQueue, opts;
      if (phraseType === 'leaf') {
        return process.nextTick(function() {
          injectionControl.args[2] = function() {};
          done();
          return deferral.resolve();
        });
      }
      if (actualPhraseType === 'boundry') {
        linkQueue = [];
        phrase.fn({
          link: function(opts) {
            return linkQueue.push(opts);
          }
        });
        if (linkQueue.length === 0) {
          return process.nextTick(function() {
            injectionControl.args[2] = function() {};
            done();
            return deferral.resolve();
          });
        }
        sequence((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = linkQueue.length; _i < _len; _i++) {
            opts = linkQueue[_i];
            _results.push((function(opts) {
              return function() {
                return BoundryHandler.link(root, opts);
              };
            })(opts));
          }
          return _results;
        })()).then(function(boundries) {
          var phrases;
          phrases = {
            refer: [],
            nest: []
          };
          boundries.reduce(function(a, b) {
            return a.concat(b);
          }).map(function(boundry) {
            return phrases[boundry.opts.mode].push({
              opts: boundry.opts,
              phrase: boundry.phrase
            });
          });
          return sequence([
            function() {
              var referPhrase;
              if (phrases.refer.length > 0) {
                return sequence((function() {
                  var _i, _len, _ref, _results;
                  _ref = phrases.refer;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    referPhrase = _ref[_i];
                    _results.push((function(referPhrase) {
                      return pipeline([
                        function() {
                          return notice.event('boundry::edge:create', {
                            vertices: [phrase, referPhrase],
                            control: phraseControl,
                            root: {
                              uuid: root.uuid
                            }
                          });
                        }, function(_arg) {
                          var phrase;
                          phrase = _arg.phrase;
                          return console.log(phrase);
                        }
                      ]);
                    })(referPhrase));
                  }
                  return _results;
                })());
              }
            }, function() {
              if (phrases.nest.length > 0) {
                return injectionControl.args[2] = function(recursor) {
                  return phrases.nest.map(function(_arg) {
                    var opts, phrase;
                    opts = _arg.opts, phrase = _arg.phrase;
                    return recursor(phrase.title, phrase.control, phrase.fn);
                  });
                };
              } else {
                return injectionControl.args[2] = function() {};
              }
            }
          ]).then(function() {
            return done();
          }, function(reject) {
            return done(reject);
          });
        }, function(reject) {
          return done(reject);
        });
        return;
      }
      return done();
    });
  };
};
