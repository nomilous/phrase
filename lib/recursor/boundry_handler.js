// Generated by CoffeeScript 1.6.3
var boundryHandler, deferred, join, readdirSync, sequence, _ref;

readdirSync = require('fs').readdirSync;

join = require('path').join;

_ref = require('also'), deferred = _ref.deferred, sequence = _ref.sequence;

module.exports = boundryHandler = {
  link: function(root, opts) {
    if (opts.directory != null) {
      return boundryHandler.linkDirectory(root, opts);
    }
  },
  linkDirectory: function(root, opts) {
    var filename, notice, regex;
    if (opts.match != null) {
      regex = new RegExp(opts.match);
    } else {
      regex = new RegExp('\\.coffee$');
    }
    notice = root.context.notice;
    notice.phrase('phrase::link:directory', {
      directory: opts.directory,
      match: regex
    });
    return sequence((function() {
      var _i, _len, _ref1, _results;
      _ref1 = boundryHandler.recurse(opts.directory, regex);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        filename = _ref1[_i];
        _results.push((function(filename) {
          return function() {
            return notice.phrase('phrase::boundry:assemble', {
              opts: {
                type: 'directory',
                filename: filename,
                stackpath: 'TODO',
                mode: 'refer'
              }
            });
          };
        })(filename));
      }
      return _results;
    })());
  },
  recurse: function(path, regex, matches) {
    var error, fileOrDirname, nextPath, _i, _len, _ref1;
    if (matches == null) {
      matches = [];
    }
    _ref1 = readdirSync(path);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      fileOrDirname = _ref1[_i];
      nextPath = join(path, fileOrDirname);
      try {
        boundryHandler.recurse(nextPath, regex, matches);
      } catch (_error) {
        error = _error;
        if (error.code !== 'ENOTDIR') {
          throw error;
        }
        if (nextPath == null) {
          throw error;
        }
        if (nextPath.match(regex)) {
          matches.push(nextPath);
        }
      }
    }
    return matches;
  }
};
