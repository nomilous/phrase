// Generated by CoffeeScript 1.6.3
var boundryHandler, defer, join, readdirSync, sequence;

readdirSync = require('fs').readdirSync;

join = require('path').join;

defer = require('when').defer;

sequence = require('when/sequence');

module.exports = boundryHandler = {
  link: function(root, opts) {
    if (opts.directory != null) {
      return boundryHandler.linkDirectory(root, opts);
    }
  },
  linkDirectory: function(root, opts) {
    var makeLinks, regex;
    makeLinks = defer();
    if (opts.match != null) {
      regex = new RegExp(opts.match);
    } else {
      regex = new RegExp('\\.coffee$');
    }
    process.nextTick(function() {
      var PhraseToken, error, filename, filenames, notice, result, _ref;
      _ref = root.context, PhraseToken = _ref.PhraseToken, notice = _ref.notice;
      try {
        filenames = boundryHandler.recurse(opts.directory, regex);
      } catch (_error) {
        error = _error;
        return makeLinks.reject(error);
      }
      return sequence((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = filenames.length; _i < _len; _i++) {
          filename = filenames[_i];
          _results.push((function(filename) {
            return function() {
              return notice.event('phrase::boundry:assemble', {
                opts: {
                  type: 'directory',
                  filename: filename,
                  stackpath: 'TODO',
                  mode: 'refer'
                }
              });
            };
          })(filename));
        }
        return _results;
      })()).then(result = function(messages) {
        var mode;
        if (messages.length === 0) {
          return makeLinks.resolve();
        }
        try {
          mode = void 0;
          messages.map(function(m) {
            if (mode == null) {
              mode = m.opts.mode;
            }
            if (mode !== m.opts.mode) {
              throw new Error('Mixed boundry modes not supported.');
            }
          });
        } catch (_error) {
          error = _error;
          return makeLinks.reject(error);
        }
        if (mode === 'nest') {
          makeLinks.notify({
            action: 'phrase::nest',
            done: function() {
              return makeLinks.resolve();
            },
            phrase: function(boundry) {
              return messages.map(function(_arg) {
                var phrase;
                phrase = _arg.phrase;
                return (function(phrase) {
                  return boundry(phrase.title, phrase.control, phrase.fn);
                })(phrase);
              });
            }
          });
        }
        return makeLinks.resolve();
      }, error = function(reject) {
        return makeLinks.reject(reject);
      });
    });
    return makeLinks.promise;
  },
  recurse: function(path, regex, matches) {
    var error, fileOrDirname, nextPath, _i, _len, _ref;
    if (matches == null) {
      matches = [];
    }
    _ref = readdirSync(path);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      fileOrDirname = _ref[_i];
      nextPath = join(path, fileOrDirname);
      try {
        boundryHandler.recurse(nextPath, regex, matches);
      } catch (_error) {
        error = _error;
        if (error.code !== 'ENOTDIR') {
          throw error;
        }
        if (nextPath == null) {
          throw error;
        }
        if (nextPath.match(regex)) {
          matches.push(nextPath);
        }
      }
    }
    return matches;
  }
};
