// Generated by CoffeeScript 1.6.3
var v1;

v1 = require('node-uuid').v1;

exports.createClass = function(root) {
  var PhraseHook, PhraseNode;
  PhraseHook = (function() {
    function PhraseHook(opts) {
      this.fn = opts.fn;
      this.uuid = v1();
      this.timeout = opts.timeout || root.timeout || 2000;
    }

    return PhraseHook;

  })();
  PhraseNode = (function() {
    var PhraseHooks;

    PhraseHooks = (function() {
      function PhraseHooks(opts) {
        var localOpts, property, _fn, _i, _len, _ref,
          _this = this;
        if (opts == null) {
          opts = {};
        }
        localOpts = {};
        _ref = ['beforeAll', 'beforeEach', 'afterEach', 'afterAll'];
        _fn = function(property) {
          localOpts[property] = opts[property];
          return Object.defineProperty(_this, property, {
            get: function() {
              return localOpts[property];
            },
            set: function(value) {
              return localOpts[property] = value;
            },
            enumerable: true
          });
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          property = _ref[_i];
          _fn(property);
        }
        Object.defineProperty(this, 'update', {
          enumerable: false,
          get: function() {
            return function(changes) {
              var thing, type, _results;
              _results = [];
              for (type in changes) {
                if (changes[type].fn != null) {
                  if (changes[type].fn.to == null) {
                    delete localOpts[type];
                    continue;
                  }
                }
                _results.push((function() {
                  var _results1;
                  _results1 = [];
                  for (thing in changes[type]) {
                    localOpts[type] || (localOpts[type] = {});
                    _results1.push(localOpts[type][thing] = changes[type][thing].to);
                  }
                  return _results1;
                })());
              }
              return _results;
            };
          }
        });
      }

      return PhraseHooks;

    })();

    function PhraseNode(opts) {
      var localOpts, property, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      if (opts.title.match(/\//)) {
        throw new Error("PhraseNode(title,opts,nestedFn) INVALID title: (=" + opts.title + ")");
      }
      localOpts = {
        uuid: opts.uuid || v1(),
        title: opts.title,
        leaf: opts.leaf,
        fn: opts.fn,
        timeout: opts.timeout || 2000,
        hooks: new PhraseHooks(opts.hooks),
        deferral: opts.deferral,
        queue: opts.queue
      };
      localOpts.token = opts.token;
      _ref = ['uuid', 'token', 'title'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          get: function() {
            return localOpts[property];
          },
          enumerable: true
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
      _ref1 = ['fn', 'timeout', 'hooks', 'deferral', 'queue'];
      _fn1 = function(property) {
        return Object.defineProperty(_this, property, {
          get: function() {
            return localOpts[property];
          },
          enumerable: false
        });
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        property = _ref1[_j];
        _fn1(property);
      }
      Object.defineProperty(this, 'leaf', {
        enumerable: true,
        get: function() {
          return localOpts.leaf;
        },
        set: function(value) {
          if (localOpts.leaf != null) {
            return;
          }
          return localOpts.leaf = value;
        }
      });
      Object.defineProperty(this, 'update', {
        enumerable: false,
        get: function() {
          return function(changes) {
            var target, thing, _k, _len2, _ref2;
            target = changes.target;
            if ((target != null) && target !== this) {
              return target.update(changes);
            }
            _ref2 = ['fn', 'timeout'];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              thing = _ref2[_k];
              if (changes[thing] != null) {
                localOpts[thing] = changes[thing].to;
              }
            }
            if (changes.hooks != null) {
              localOpts.hooks.update(changes.hooks);
            }
            if (changes.type != null) {
              return localOpts.token.type = changes.type.to;
            }
          };
        }
      });
    }

    PhraseNode.prototype.getChanges = function(vertex) {
      var changes, currentFn, currentTimeout, from, hookType, latestFn, latestTimeout, property, to, tokenProperty, _base, _base1, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      changes = void 0;
      _ref = ['fn', 'timeout'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        from = (function() {
          try {
            return this[property].toString();
          } catch (_error) {}
        }).call(this);
        to = (function() {
          try {
            return vertex[property].toString();
          } catch (_error) {}
        })();
        if (from !== to) {
          changes || (changes = {
            target: this
          });
          changes[property] = {
            from: this[property],
            to: vertex[property]
          };
        }
      }
      _ref1 = ['type'];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tokenProperty = _ref1[_j];
        from = (function() {
          try {
            return this.token[tokenProperty];
          } catch (_error) {}
        }).call(this);
        to = (function() {
          try {
            return vertex.token[tokenProperty];
          } catch (_error) {}
        })();
        if (from !== to) {
          changes || (changes = {
            target: this
          });
          changes[tokenProperty] = {
            from: this.token[tokenProperty],
            to: vertex.token[tokenProperty]
          };
        }
      }
      _ref2 = ['beforeAll', 'beforeEach', 'afterEach', 'afterAll'];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        hookType = _ref2[_k];
        currentFn = (function() {
          try {
            return this.hooks[hookType].fn.toString();
          } catch (_error) {}
        }).call(this);
        currentTimeout = (function() {
          try {
            return this.hooks[hookType].timeout;
          } catch (_error) {}
        }).call(this);
        latestFn = (function() {
          try {
            return vertex.hooks[hookType].fn.toString();
          } catch (_error) {}
        })();
        latestTimeout = (function() {
          try {
            return vertex.hooks[hookType].timeout;
          } catch (_error) {}
        })();
        if (currentFn !== latestFn) {
          changes || (changes = {
            target: this
          });
          changes.hooks || (changes.hooks = {});
          (_base = changes.hooks)[hookType] || (_base[hookType] = {});
          changes.hooks[hookType].fn = {
            from: (function() {
              try {
                return this.hooks[hookType].fn;
              } catch (_error) {}
            }).call(this),
            to: (function() {
              try {
                return vertex.hooks[hookType].fn;
              } catch (_error) {}
            })()
          };
        }
        if (currentTimeout !== latestTimeout) {
          changes || (changes = {
            target: this
          });
          changes.hooks || (changes.hooks = {});
          (_base1 = changes.hooks)[hookType] || (_base1[hookType] = {});
          changes.hooks[hookType].timeout = {
            from: (function() {
              try {
                return this.hooks[hookType].timeout;
              } catch (_error) {}
            }).call(this),
            to: (function() {
              try {
                return vertex.hooks[hookType].timeout;
              } catch (_error) {}
            })()
          };
        }
      }
      return changes;
    };

    return PhraseNode;

  })();
  Object.defineProperty(PhraseNode, 'PhraseHook', {
    enumerable: true,
    get: function() {
      return PhraseHook;
    }
  });
  return PhraseNode;
};
