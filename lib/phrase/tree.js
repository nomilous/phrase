// Generated by CoffeeScript 1.6.3
var ChangeSetFactory, pipeline, seq;

pipeline = require('also').pipeline;

ChangeSetFactory = require('./change_set');

seq = 0;

exports.createClass = function(root) {
  var ChangeSet, PhraseTree, assembler, context, notice, trees, util;
  context = root.context, util = root.util;
  notice = context.notice;
  context.trees = trees = {
    latest: null,
    list: {}
  };
  ChangeSet = ChangeSetFactory.createClass(root);
  notice.use({
    title: 'phrase tree assmebler'
  }, assembler = function(next, capsule) {
    if (trees.latest == null) {
      return next();
    }
    switch (capsule.phrase) {
      case 'phrase::recurse:start':
        return next();
      case 'phrase::edge:create':
        if (capsule.root.uuid !== root.uuid) {
          return next();
        }
        return trees.latest.registerEdge(next, capsule);
      case 'phrase::recurse:end':
        if (capsule.root.uuid !== root.uuid) {
          return next();
        }
        return trees.latest.createIndexes(next, capsule);
      default:
        return next();
    }
  });
  PhraseTree = (function() {
    function PhraseTree(opts) {
      var historyLength, localOpts, order, property, uuid, _fn, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      localOpts = {
        uuid: opts.uuid || util.uuid(),
        version: opts.version || ++seq,
        rootVertex: void 0,
        vertices: {},
        edges: {},
        path2uuid: {},
        uuid2path: {},
        parent: {},
        children: {},
        leaves: []
      };
      trees.list[localOpts.uuid] = this;
      trees.latest = this;
      order = [];
      historyLength = 2;
      for (uuid in trees.list) {
        order.push(uuid);
      }
      _ref = order.slice(0, +(-1 - historyLength) + 1 || 9e9);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        uuid = _ref[_i];
        delete trees.list[uuid];
      }
      _ref1 = ['uuid', 'version', 'vertices', 'edges', 'path2uuid', 'uuid2path', 'parent', 'children', 'leaves', 'tree'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          get: function() {
            return localOpts[property];
          },
          enumerable: true
        });
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        property = _ref1[_j];
        _fn(property);
      }
      Object.defineProperty(this, 'rootVertex', {
        enumerable: false,
        get: function() {
          return localOpts.rootVertex;
        },
        set: function(value) {
          if (localOpts.rootVertex == null) {
            return localOpts.rootVertex = value;
          }
        }
      });
    }

    PhraseTree.prototype.createIndexes = function(next, capsule) {
      var recurse,
        _this = this;
      capsule.tokens = {};
      recurse = function(vertex, stack) {
        var path, signature, title, uuid, _i, _len, _ref;
        if (stack == null) {
          stack = [];
        }
        signature = vertex.token.signature;
        title = vertex.title;
        stack.push("/" + signature + "/" + title);
        path = stack.join('');
        _this.path2uuid[path] = vertex.uuid;
        _this.uuid2path[vertex.uuid] = path;
        capsule.tokens[path] = vertex.token;
        if (_this.children[vertex.uuid] != null) {
          _ref = _this.children[vertex.uuid];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            uuid = _ref[_i];
            recurse(_this.vertices[uuid], stack);
          }
        }
        return stack.pop();
      };
      recurse(this.rootVertex);
      return next();
    };

    PhraseTree.prototype.findRoute = function(uuidA, uuidB) {
      var recurse,
        _this = this;
      if (uuidA != null) {
        throw new Error('PhraseTree.route(null, uuidB) only supports tree route calculation from root to uuidB');
      }
      recurse = function(uuid, uuids) {
        if (uuids == null) {
          uuids = [];
        }
        if (uuid == null) {
          return uuids;
        }
        uuids.unshift(uuid);
        return recurse(_this.parent[uuid], uuids);
      };
      return recurse(uuidB);
    };

    PhraseTree.prototype.update = function() {
      return pipeline([
        function() {
          return notice.phrase('tree::compare:start');
        }, function() {
          return new ChangeSet(context.tree, context.trees.latest).changes;
        }, function(changes) {
          return notice.phrase('tree::compare:end', {
            changes: changes
          });
        }, function(message) {
          return notice.phrase('tree::update:start', message);
        }, function(message) {
          if (message.skipChange) {
            return {
              skipped: true
            };
          }
          return ChangeSet.applyChanges(message.changes.uuid);
        }, function(updated) {
          return notice.phrase('tree::update:end', updated);
        }
      ]);
    };

    PhraseTree.prototype.registerEdge = function(next, capsule) {
      var vertex1, vertex2, _base, _base1, _base2, _name, _name1, _name2, _ref;
      _ref = capsule.vertices, vertex1 = _ref[0], vertex2 = _ref[1];
      this.vertices[vertex1.uuid] = vertex1;
      if (this.rootVertex == null) {
        this.rootVertex = vertex1;
      }
      if (vertex2 == null) {
        return next();
      }
      this.vertices[vertex2.uuid] = vertex2;
      (_base = this.edges)[_name = vertex1.uuid] || (_base[_name] = []);
      this.edges[vertex1.uuid].push({
        to: vertex2.uuid
      });
      (_base1 = this.edges)[_name1 = vertex2.uuid] || (_base1[_name1] = []);
      this.edges[vertex2.uuid].push({
        to: vertex1.uuid
      });
      (_base2 = this.children)[_name2 = vertex1.uuid] || (_base2[_name2] = []);
      this.children[vertex1.uuid].push(vertex2.uuid);
      this.parent[vertex2.uuid] = vertex1.uuid;
      if ((vertex2.token != null) && vertex2.token.type === 'leaf') {
        this.leaves.push(vertex2.uuid);
      }
      return next();
    };

    PhraseTree.prototype.leavesOf = function(uuid, found) {
      var child_uuid, _i, _len, _ref;
      if (found == null) {
        found = [];
      }
      if (this.vertices[uuid] == null) {
        return found;
      }
      if ((this.vertices[uuid].token != null) && this.vertices[uuid].token.type === 'leaf') {
        found.push(this.vertices[uuid]);
        return found;
      }
      _ref = this.children[uuid];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child_uuid = _ref[_i];
        this.leavesOf(child_uuid, found);
      }
      return found;
    };

    return PhraseTree;

  })();
  Object.defineProperty(PhraseTree, 'assembler', {
    enumerable: false,
    get: function() {
      return assembler;
    }
  });
  return PhraseTree;
};
