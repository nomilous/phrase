// Generated by CoffeeScript 1.6.3
var defer, sequence, v1;

v1 = require('node-uuid').v1;

defer = require('when').defer;

sequence = require('when/sequence');

exports.create = function(root) {
  var PhraseJob, inject;
  inject = root.inject;
  return PhraseJob = (function() {
    function PhraseJob(opts) {
      var localOpts, property, _fn, _i, _len, _ref,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      opts.uuid || (opts.uuid = v1());
      opts.deferral || (opts.deferral = {
        reject: function(error) {
          throw error;
        },
        notify: function(update) {
          return console.log('PhraseJob:', JSON.stringify(update));
        }
      });
      localOpts = {
        progress: function() {
          return {
            steps: opts.steps != null ? opts.steps.length : 0,
            done: opts.steps.filter(function(s) {
              return s.done;
            }).length,
            failed: opts.steps.filter(function(s) {
              return s.fail;
            }).length,
            skipped: opts.steps.filter(function(s) {
              return s.skip;
            }).length
          };
        }
      };
      _ref = ['uuid', 'steps', 'deferral', 'progress'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          enumerable: false,
          get: function() {
            return localOpts[property] || opts[property];
          },
          set: function(value) {
            return opts.deferral.reject(new Error("Cannot assign reserved property: " + property + "(=" + value + ")"));
          }
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
    }

    PhraseJob.prototype.run = function() {
      var running,
        _this = this;
      this.deferral.notify({
        state: 'run::starting',
        "class": this.constructor.name,
        jobUUID: this.uuid,
        progress: this.progress(),
        at: Date.now()
      });
      running = defer();
      sequence(this.steps.map(function(step) {
        var injectionConfig;
        injectionConfig = {
          context: _this,
          onError: function(type, error, deferral) {
            var s, state, _i, _len, _ref;
            _ref = _this.steps;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              s = _ref[_i];
              if (s.set !== step.set) {
                continue;
              }
              if (!(s.depth >= step.depth)) {
                continue;
              }
              if (s === step) {
                s.fail = true;
                state = 'run::step:failed';
              } else {
                s.skip = true;
                state = 'run::step:skipped';
              }
              _this.deferral.notify({
                state: state,
                "class": _this.constructor.name,
                jobUUID: _this.uuid,
                progress: _this.progress(),
                at: Date.now()
              });
            }
            return deferral.resolve();
          },
          beforeEach: function(done, control) {
            var hasTimedOut, targetDefer, timeout;
            if (step.skip) {
              control.skip();
              done();
            }
            hasTimedOut = false;
            targetDefer = control.defer;
            if (!(step.type === 'leaf' || control.signature[0] === 'done')) {
              setTimeout(targetDefer.resolve, 1);
              done();
              return;
            }
            timeout = setTimeout((function() {
              hasTimedOut = true;
              return injectionConfig.onError(null, new Error('timeout'), targetDefer);
            }), step.ref.timeout || 2000);
            control.args[0] = function() {
              clearTimeout(timeout);
              if (hasTimedOut) {
                return;
              }
              return targetDefer.resolve();
            };
            done();
          },
          afterEach: function(done) {
            if (!(step.skip || step.fail)) {
              step.done = true;
              _this.deferral.notify({
                state: 'run::step:done',
                "class": _this.constructor.name,
                jobUUID: _this.uuid,
                progress: _this.progress(),
                at: Date.now()
              });
            }
            return done();
          }
        };
        return inject.async(injectionConfig, step.ref.fn);
      })).then(function() {
        _this.deferral.notify({
          state: 'run::complete',
          "class": _this.constructor.name,
          jobUUID: _this.uuid,
          progress: _this.progress(),
          at: Date.now()
        });
        return running.resolve({
          job: _this
        });
      }, function(error) {
        return console.log('ERROR_IN_PHRASE_JOB', error.stack);
      }, function(notify) {});
      return running.promise;
    };

    return PhraseJob;

  })();
};
