// Generated by CoffeeScript 1.6.3
var defer, sequence, v1;

v1 = require('node-uuid').v1;

defer = require('when').defer;

sequence = require('when/sequence');

exports.create = function(root) {
  var PhraseJob, inject;
  inject = root.inject;
  return PhraseJob = (function() {
    function PhraseJob(opts) {
      var localOpts, property, _fn, _i, _len, _ref,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      opts.uuid || (opts.uuid = v1());
      opts.deferral || (opts.deferral = {
        reject: function(error) {
          throw error;
        },
        notify: function(update) {
          return console.log('PhraseJob:', JSON.stringify(update));
        }
      });
      localOpts = {
        progress: function() {
          return {
            steps: opts.steps != null ? opts.steps.length : 0,
            done: opts.steps.map(function(s) {
              return s.done;
            }).length
          };
        }
      };
      _ref = ['uuid', 'steps', 'deferral', 'progress'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          enumerable: false,
          get: function() {
            return localOpts[property] || opts[property];
          },
          set: function(value) {
            return opts.deferral.reject(new Error("Cannot assign reserved property: " + property + "(=" + value + ")"));
          }
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
    }

    PhraseJob.prototype.run = function() {
      var running,
        _this = this;
      this.deferral.notify({
        state: 'run::starting',
        "class": this.constructor.name,
        uuid: this.uuid,
        progress: this.progress(),
        at: Date.now()
      });
      running = defer();
      sequence(this.steps.map(function(step) {
        return inject.async({
          context: _this,
          notifyOnError: true,
          beforeEach: function(done, control) {
            var targetDefer, timeout;
            targetDefer = control.defer;
            if (!(step.type === 'leaf' || control.signature[0] === 'done')) {
              setTimeout(targetDefer.resolve, 1);
              done();
              return;
            }
            timeout = setTimeout((function() {
              return targetDefer.notify({
                event: 'timeout',
                "class": _this.constructor.name,
                uuid: _this.uuid,
                step: step,
                at: Date.now(),
                defer: targetDefer
              });
            }), step.ref.timeout || 2000);
            control.args[0] = function() {
              clearTimeout(timeout);
              return targetDefer.resolve();
            };
            done();
          },
          afterEach: function(done) {
            step.done = true;
            return done();
          }
        }, step.ref.fn);
      })).then(function() {
        _this.deferral.notify({
          state: 'run::complete',
          "class": _this.constructor.name,
          uuid: _this.uuid,
          progress: _this.progress(),
          at: Date.now()
        });
        return running.resolve({
          job: _this
        });
      }, function(error) {
        return console.log('ERROR_IN_PHRASE_JOB', error.stack);
      }, function(notify) {
        if (notify.event === 'error' || notify.event === 'timeout') {
          console.log({
            HANDLE_TIMEOUT_OR_ERROR: notify
          });
          notify.defer.resolve();
          delete notify.defer;
          running.notify(notify);
        }
      });
      return running.promise;
    };

    return PhraseJob;

  })();
};
