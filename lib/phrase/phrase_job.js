// Generated by CoffeeScript 1.6.3
var defer, sequence, v1;

v1 = require('node-uuid').v1;

defer = require('when').defer;

sequence = require('when/sequence');

exports.create = function(root) {
  var PhraseJob, inject;
  inject = root.inject;
  return PhraseJob = (function() {
    function PhraseJob(opts) {
      var localOpts, property, _fn, _i, _len, _ref,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      opts.uuid || (opts.uuid = v1());
      opts.deferral || (opts.deferral = {
        reject: function(error) {
          throw error;
        },
        notify: function(update) {
          return console.log('PhraseJob:', JSON.stringify(update));
        }
      });
      localOpts = {
        progress: function() {
          return {
            steps: opts.steps != null ? opts.steps.length : 0,
            done: opts.steps.filter(function(s) {
              return s.done;
            }).length
          };
        }
      };
      _ref = ['uuid', 'steps', 'deferral', 'progress'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          enumerable: false,
          get: function() {
            return localOpts[property] || opts[property];
          },
          set: function(value) {
            return opts.deferral.reject(new Error("Cannot assign reserved property: " + property + "(=" + value + ")"));
          }
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
    }

    PhraseJob.prototype.handleError = function(error, deferral, step) {
      console.log({
        HANDLE_ERROR: {
          error: error,
          deferral: deferral,
          step: step
        }
      });
      return deferral.resolve();
    };

    PhraseJob.prototype.run = function() {
      var running,
        _this = this;
      this.deferral.notify({
        state: 'run::starting',
        "class": this.constructor.name,
        jobUUID: this.uuid,
        progress: this.progress(),
        at: Date.now()
      });
      running = defer();
      sequence(this.steps.map(function(step) {
        if (step.done) {
          return function() {
            if (step.type === 'leaf') {
              return _this.deferral.notify({
                event: 'skip',
                "class": _this.constructor.name,
                jobUUID: _this.uuid,
                progress: _this.progress(),
                at: Date.now()
              });
            }
          };
        }
        return inject.async({
          context: _this,
          beforeEach: function(done, control) {
            var targetDefer;
            targetDefer = control.defer;
            if (!(step.type === 'leaf' || control.signature[0] === 'done')) {
              setTimeout(targetDefer.resolve, 1);
              done();
              return;
            }
            console.log('TODO: timeout as error');
            done();
          },
          afterEach: function(done) {
            step.done = true;
            _this.deferral.notify({
              state: 'run::started',
              "class": _this.constructor.name,
              jobUUID: _this.uuid,
              progress: _this.progress(),
              at: Date.now()
            });
            return done();
          },
          onError: function(type, error, deferral) {
            return _this.handleError(error, deferral, step);
          }
        }, step.ref.fn);
      })).then(function() {
        _this.deferral.notify({
          state: 'run::complete',
          "class": _this.constructor.name,
          jobUUID: _this.uuid,
          progress: _this.progress(),
          at: Date.now()
        });
        return running.resolve({
          job: _this
        });
      }, function(error) {
        return console.log('ERROR_IN_PHRASE_JOB', error.stack);
      }, function(notify) {});
      return running.promise;
    };

    return PhraseJob;

  })();
};
