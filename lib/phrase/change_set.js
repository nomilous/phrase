// Generated by CoffeeScript 1.6.3
var defer;

defer = require('when').defer;

exports.createClass = function(root) {
  var ChangeSet, changeSets, util;
  util = root.util;
  changeSets = {};
  ChangeSet = (function() {
    function ChangeSet(treeA, treeB) {
      var changes, historyLength, newTree, newUUID, newVertex, order, parentPath, path, runningTree, runningUUID, runningVertex, uuid, vertex, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _base9, _i, _len, _ref;
      this.treeA = treeA;
      this.treeB = treeB;
      historyLength = 1;
      this.uuid = util.uuid();
      this.changes = {
        uuid: this.uuid
      };
      changeSets[this.uuid] = this;
      runningTree = this.treeA;
      newTree = this.treeB;
      order = [];
      for (uuid in changeSets) {
        order.push(uuid);
      }
      _ref = order.slice(0, +(-1 - historyLength) + 1 || 9e9);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        uuid = _ref[_i];
        delete changeSets[uuid];
      }
      for (path in runningTree.path2uuid) {
        runningUUID = runningTree.path2uuid[path];
        runningVertex = runningTree.vertices[runningUUID];
        newUUID = newTree.path2uuid[path];
        if (newUUID == null) {
          (_base = this.changes).deleted || (_base.deleted = {});
          this.changes.deleted[path] = runningVertex;
          continue;
        }
        newVertex = newTree.vertices[newUUID];
        if (changes = runningVertex.getChanges(newVertex)) {
          if (changes.type != null) {
            (_base1 = this.changes).updated || (_base1.updated = {});
            (_base2 = this.changes.updated)[path] || (_base2[path] = {});
            this.changes.updated[path].type = changes.type;
          }
          if (changes.fn != null) {
            if (runningVertex.token.type === 'leaf') {
              (_base3 = this.changes).updated || (_base3.updated = {});
              (_base4 = this.changes.updated)[path] || (_base4[path] = {});
              this.changes.updated[path].fn = changes.fn;
            }
          }
          if (changes.timeout != null) {
            (_base5 = this.changes).updated || (_base5.updated = {});
            (_base6 = this.changes.updated)[path] || (_base6[path] = {});
            this.changes.updated[path].timeout = changes.timeout;
          }
          if (changes.hooks != null) {
            parentPath = path.split('/').slice(0, -2).join('/');
            (_base7 = this.changes).updated || (_base7.updated = {});
            (_base8 = this.changes.updated)[parentPath] || (_base8[parentPath] = {});
            this.changes.updated[parentPath].hooks = changes.hooks;
            this.changes.updated[parentPath].target = changes.target;
          }
        }
      }
      for (path in newTree.path2uuid) {
        if (runningTree.path2uuid[path] == null) {
          uuid = newTree.path2uuid[path];
          vertex = newTree.vertices[uuid];
          (_base9 = this.changes).created || (_base9.created = {});
          this.changes.created[path] = vertex;
          continue;
        }
      }
    }

    ChangeSet.prototype.AtoB = function() {
      var child, childUUID, hook, leaf, newHook, parent, parentB, parentUUID, path, stillParent, target, type, uuid, _base, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (this.changes.deleted != null) {
        for (path in this.changes.deleted) {
          uuid = this.treeA.path2uuid[path];
          delete this.treeA.path2uuid[path];
          delete this.treeA.uuid2path[uuid];
          try {
            parent = this.treeA.parent[uuid];
            this.treeA.edges[parent] = this.treeA.edges[parent].filter(function(edge) {
              return edge.to !== uuid;
            });
          } catch (_error) {}
          delete this.treeA.edges[uuid];
          delete this.treeA.parent[uuid];
          delete this.treeA.children[uuid];
          delete this.treeA.vertices[uuid];
        }
      }
      if (this.changes.created != null) {
        for (path in this.changes.created) {
          uuid = this.changes.created[path].uuid;
          this.treeA.vertices[uuid] = this.changes.created[path];
          this.treeA.path2uuid[path] = this.changes.created[path].uuid;
          this.treeA.uuid2path[uuid] = path;
          parentB = this.treeB.parent[uuid];
          parent = this.treeA.path2uuid[this.treeB.uuid2path[parentB]];
          this.treeA.edges[uuid] = [
            {
              to: parent
            }
          ];
          (_base = this.treeA.edges)[parent] || (_base[parent] = []);
          this.treeA.edges[parent].push({
            to: uuid
          });
        }
      }
      stillParent = {};
      for (parentUUID in this.treeB.children) {
        parent = this.treeA.path2uuid[this.treeB.uuid2path[parentUUID]] || parentUUID;
        this.treeA.children[parent] = [];
        stillParent[parent] = !this.treeB.vertices[parentUUID].leaf;
        _ref = this.treeB.children[parentUUID];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childUUID = _ref[_i];
          child = this.treeA.path2uuid[this.treeB.uuid2path[childUUID]] || childUUID;
          this.treeA.children[parent].push(child);
          this.treeA.parent[child] = parent;
        }
      }
      for (parentUUID in this.treeA.children) {
        if (!stillParent[parentUUID]) {
          delete this.treeA.children[parentUUID];
        }
      }
      this.treeA.leaves.length = 0;
      _ref1 = this.treeB.leaves;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        leaf = _ref1[_j];
        this.treeA.leaves.push(this.treeA.path2uuid[this.treeB.uuid2path[leaf]] || leaf);
      }
      if (this.changes.updated != null) {
        _results = [];
        for (path in this.changes.updated) {
          target = this.treeA.vertices[this.treeA.path2uuid[path]];
          target.update(this.changes.updated[path]);
          if (this.changes.updated[path].hooks != null) {
            _results.push((function() {
              var _k, _len2, _ref2, _results1;
              _ref2 = ['beforeAll', 'beforeEach', 'afterEach', 'afterAll'];
              _results1 = [];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                type = _ref2[_k];
                hook = this.changes.updated[path].hooks[type];
                if ((hook != null) && !((hook.fn.from != null) || (hook.timeout.from != null))) {
                  newHook = new root.context.PhraseNode.PhraseHook({
                    timeout: hook.timeout.to,
                    fn: hook.fn.to
                  });
                  parentUUID = this.treeA.path2uuid[path];
                  _results1.push((function() {
                    var _l, _len3, _ref3, _results2;
                    _ref3 = this.treeA.children[parentUUID];
                    _results2 = [];
                    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                      childUUID = _ref3[_l];
                      _results2.push(this.treeA.vertices[childUUID].hooks[type] = newHook);
                    }
                    return _results2;
                  }).call(this));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    return ChangeSet;

  })();
  return Object.defineProperty(ChangeSet, 'applyChanges', {
    enumarable: true,
    get: function() {
      return function(uuid, direction) {
        var doing;
        doing = defer();
        process.nextTick(function() {
          if (changeSets[uuid] == null) {
            return doing.reject(new Error('ChangeSet.applyChanges() has no set with uuid: ' + uuid));
          }
          return doing.resolve(changeSets[uuid][direction || 'AtoB']());
        });
        return doing.promise;
      };
    }
  });
};
