// Generated by CoffeeScript 1.6.3
var api, defer, error, pipeline;

defer = require('when').defer;

pipeline = require('when/pipeline');

error = function(code, message) {
  return Object.defineProperty(new Error(message), 'code', {
    value: code
  });
};

api = {
  run: function(root, opts) {
    var context, graph, running, uuid;
    context = root.context;
    graph = context.graph;
    uuid = opts.uuid;
    running = defer();
    process.nextTick(function() {
      if (uuid == null) {
        return running.reject(error(1, "missing opts.uuid"));
      }
      if (graph.vertices[uuid] == null) {
        return running.reject(error(2, "uuid: '" + uuid + "' not in local tree"));
      }
    });
    pipeline([
      function() {
        return api.getSteps(root, opts, running);
      }, function(steps) {
        var job;
        job = new context.PhraseJob({
          steps: steps,
          deferral: running
        });
        return job.run();
      }
    ]).then(function(result) {
      return running.resolve(result);
    }, function(error) {
      return running.reject(error);
    }, function(update) {
      return running.notify(update);
    });
    return running.promise;
  },
  getSteps: function(root, opts, running) {
    var afters, befores, context, count, getting, graph, leaves, recurse, set, start, steps, uuid;
    context = root.context;
    graph = context.graph;
    uuid = opts.uuid;
    getting = defer();
    leaves = graph.leavesOf(uuid);
    count = leaves.length;
    steps = [];
    befores = {};
    afters = {};
    set = 0;
    start = recurse = function() {
      var inbound, leaf, outbound, path, remaining;
      set++;
      remaining = leaves.length;
      if (remaining === 0) {
        steps = steps.filter(function(s) {
          return s != null;
        });
        running.notify({
          state: 'scan::complete',
          at: Date.now(),
          steps: steps.length,
          leaves: count
        });
        return getting.resolve(steps);
      }
      leaf = leaves.shift();
      path = graph.tree.leaves[leaf.uuid].path;
      outbound = [];
      inbound = path.map(function(uuid) {
        outbound.unshift(graph.vertices[uuid]);
        return graph.vertices[uuid];
      });
      inbound.map(function(phrase) {
        var beforeAll, beforeEach, position, _ref;
        _ref = phrase.hooks, beforeAll = _ref.beforeAll, beforeEach = _ref.beforeEach;
        if (beforeAll != null) {
          if (befores[beforeAll.uuid] == null) {
            position = steps.push({
              sets: [],
              type: 'hook',
              ref: beforeAll
            }) - 1;
            befores[beforeAll.uuid] = position;
          }
          position = befores[beforeAll.uuid];
          steps[position].sets.push(set);
        }
        if (beforeEach != null) {
          return steps.push({
            set: set,
            type: 'hook',
            ref: beforeEach
          });
        }
      });
      steps.push({
        set: set,
        type: 'leaf',
        ref: leaf
      });
      outbound.map(function(phrase) {
        var afterAll, afterEach, oldPosition, position, pset, step, _i, _len, _ref, _ref1;
        _ref = phrase.hooks, afterEach = _ref.afterEach, afterAll = _ref.afterAll;
        if (afterEach != null) {
          steps.push({
            set: set,
            type: 'hook',
            ref: afterEach
          });
        }
        if (afterAll != null) {
          step = {
            sets: [set],
            type: 'hook',
            ref: afterAll
          };
          position = steps.push(step) - 1;
          if (afters[afterAll.uuid] != null) {
            oldPosition = afters[afterAll.uuid];
            _ref1 = steps[oldPosition].sets;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              pset = _ref1[_i];
              step.sets.push(pset);
            }
            delete steps[oldPosition];
          }
          return afters[afterAll.uuid] = position;
        }
      });
      return recurse();
    };
    running.notify({
      state: 'scan::starting',
      at: Date.now()
    });
    start();
    return getting.promise;
  }
};

module.exports = api;
