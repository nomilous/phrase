// Generated by CoffeeScript 1.6.3
var api, defer, error, map, sequence, _ref;

_ref = require('when'), defer = _ref.defer, map = _ref.map;

sequence = require('when/sequence');

error = function(code, message) {
  return Object.defineProperty(new Error(message), 'code', {
    value: code
  });
};

api = {
  run: function(root, opts) {
    var context, graph, running, uuid;
    context = root.context;
    graph = context.graph;
    uuid = opts.uuid;
    running = defer();
    process.nextTick(function() {
      if (uuid == null) {
        return running.reject(error(1, "missing opts.uuid"));
      }
      if (graph.vertices[uuid] == null) {
        return running.reject(error(2, "uuid: '" + uuid + "' not in local tree"));
      }
    });
    api.getSteps(root, opts, running).then(function(steps) {});
    return running.promise;
  },
  getSteps: function(root, opts, running) {
    var afters, befores, context, count, getting, graph, leaves, recurse, steps, uuid;
    context = root.context;
    graph = context.graph;
    uuid = opts.uuid;
    getting = defer();
    leaves = graph.leavesOf(uuid);
    count = leaves.length;
    steps = [];
    befores = {};
    afters = {};
    recurse = function() {
      var inbound, leaf, outbound, path, remaining;
      remaining = leaves.length;
      if (remaining === 0) {
        return getting.resolve(steps.filter(function(s) {
          return s != null;
        }));
      }
      leaf = leaves.shift();
      path = graph.tree.leaves[leaf.uuid].path;
      outbound = [];
      inbound = path.map(function(uuid) {
        outbound.unshift(graph.vertices[uuid]);
        return graph.vertices[uuid];
      });
      return sequence([
        function() {
          return map(inbound, function(phrase) {
            var beforeAll, beforeEach, position, _ref1;
            _ref1 = phrase.hooks, beforeAll = _ref1.beforeAll, beforeEach = _ref1.beforeEach;
            if ((beforeAll != null) && (befores[beforeAll.uuid] == null)) {
              position = steps.push({
                type: 'hook',
                ref: beforeAll
              }) - 1;
              befores[beforeAll.uuid] = position;
            }
            if (beforeEach != null) {
              return steps.push({
                type: 'hook',
                ref: beforeEach
              });
            }
          });
        }, function() {
          return steps.push({
            type: 'leaf',
            ref: leaf
          });
        }, function() {
          return map(outbound, function(phrase) {
            var afterAll, afterEach, oldPosition, position, _ref1;
            _ref1 = phrase.hooks, afterEach = _ref1.afterEach, afterAll = _ref1.afterAll;
            if (afterEach != null) {
              steps.push({
                type: 'hook',
                ref: afterEach
              });
            }
            if (afterAll != null) {
              position = steps.push({
                type: 'hook',
                ref: afterAll
              }) - 1;
              if (afters[afterAll.uuid] != null) {
                oldPosition = afters[afterAll.uuid];
                delete steps[oldPosition];
              }
              return afters[afterAll.uuid] = position;
            }
          });
        }
      ]).then(recurse);
    };
    recurse();
    return getting.promise;
  }
};

module.exports = api;
