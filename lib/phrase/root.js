// Generated by CoffeeScript 1.6.3
var AccessToken, Job, Notice, PhraseNode, PhraseTree, TreeWalker;

Notice = require('notice');

PhraseNode = require('./node');

PhraseTree = require('./tree');

AccessToken = require('../token/access_token');

TreeWalker = require('../recursor/tree_walker');

Job = require('../runner/job');

exports.createClass = function(root) {
  var context, validate;
  context = root.context, validate = root.validate;
  if (context == null) {
    root.context = context = {};
  }
  return {
    createRoot: validate.args({
      $address: 'phrase.createRoot',
      opts: {
        title: {},
        uuid: {},
        leaf: {
          $default: ['end', 'done'],
          $description: "\nThis specifies an array of possible phraseFn arg1 signature names \nthat are used to determine if the phrase function is a leaf.\n\n    eg. \n\n    phraseRegistrar 'phrase title', (end) -> \n\n        # \n        # this is a leaf function\n        # \n"
        },
        boundry: {
          $default: ['edge'],
          $description: "\nThis specifies an array of possible phraseFn arg1 signature names \nthat are used to determine if the phrase function is a boundry\nlink to another phrase tree.\n\n    eg. \n\n    phraseRegistrar 'phrase title', (edge) -> \n\n        # \n        # TODO...\n        # \n"
        },
        timeout: {
          $default: 2000,
          $description: "\nThis specifies how long to allow asynchronous hooks or leaves\nto run before it is assumed they will not complete.\n\neg. \n\nbefore each: (done) -> \n\n    #\n    # has the default 2 seconds to call done() or it will timeout\n    #\n"
        }
      },
      linkFn: {
        $type: Function,
        $description: "\nThis callback is called immediately upon initialization of the\nphrase root. It receives the phrase tree access token and a\nmiddleware registrar that enables tapping into the chatter \ntraversing the phrase tree's internal message bus.\n"
      }
    }, function(opts, linkFn) {
      context.notice = Notice.create(opts.uuid);
      root.timeout = opts.timeout;
      return function(phraseRootString, phraseRootFn) {
        var promise;
        if (context.walking != null) {
          throw new Error('Phrase root registrar cannot perform concurrent walks');
        }
        if (context.token == null) {
          context.PhraseTree = PhraseTree.createClass(root);
          context.PhraseNode = PhraseNode.createClass(root);
          context.Job = Job.createClass(root);
          context.token = AccessToken.create(root);
          promise = TreeWalker.walk(root, opts, phraseRootString, phraseRootFn);
          linkFn(context.token, context.notice);
          return promise;
        }
        return TreeWalker.walk(root, opts, phraseRootString, phraseRootFn);
      };
    })
  };
};
