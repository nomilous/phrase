// Generated by CoffeeScript 1.6.3
var defer, sequence, v1;

v1 = require('node-uuid').v1;

defer = require('when').defer;

sequence = require('when/sequence');

exports.createClass = function(root) {
  var Job, context, inject, notice;
  inject = root.inject, context = root.context;
  notice = context.notice;
  return Job = (function() {
    function Job(opts) {
      var localOpts, param, property, _fn, _i, _len, _ref,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      opts.uuid || (opts.uuid = v1());
      opts.deferral || (opts.deferral = {
        reject: function(error) {
          throw error;
        },
        notify: function(update) {
          return console.log('Job:', JSON.stringify(update));
        }
      });
      localOpts = {
        notice: notice,
        progress: function() {
          return {
            steps: opts.steps != null ? opts.steps.length : 0,
            done: opts.steps.filter(function(s) {
              return s.done;
            }).length,
            failed: opts.steps.filter(function(s) {
              return s.fail;
            }).length,
            skipped: opts.steps.filter(function(s) {
              return s.skip;
            }).length
          };
        }
      };
      _ref = ['notice', 'uuid', 'steps', 'deferral', 'progress'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          enumerable: false,
          get: function() {
            return localOpts[property] || opts[property];
          },
          set: function(value) {
            opts.deferral.reject(new Error("Cannot assign reserved property: " + property + "(=" + value + ")"));
            return localOpts.skipped = true;
          }
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
      Object.defineProperty(this, 'skipped', {
        enumarable: false,
        get: function() {
          return localOpts.skipped || false;
        },
        set: function(value) {
          if (localOpts.skipped == null) {
            return localOpts.skipped = value;
          }
        }
      });
      if (opts.params != null) {
        for (param in opts.params) {
          this[param] = opts.params[param];
        }
      }
    }

    Job.prototype.run = function() {
      var message, running,
        _this = this;
      running = defer();
      if (this.skipped) {
        process.nextTick(function() {
          return running.resolve({
            job: _this
          });
        });
        return running.promise;
      }
      message = {
        update: 'run::starting',
        "class": this.constructor.name,
        jobUUID: this.uuid,
        progress: this.progress(),
        at: Date.now()
      };
      this.notice.event(message.update, message).then(function() {
        _this.deferral.notify(message);
        return sequence(_this.steps.map(function(step) {
          var injectionConfig;
          injectionConfig = {
            context: _this,
            onError: function(done, context, error) {
              var intersect, s, skipped, update, _i, _len, _ref;
              skipped = [];
              _ref = _this.steps;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                if (s.depth < step.depth) {
                  continue;
                }
                if (step.set != null) {
                  if (s.set != null) {
                    if (s.set !== step.set) {
                      continue;
                    }
                  }
                } else {
                  if (s.set != null) {
                    intersect = step.sets.filter(function(skipSet) {
                      return s.set === skipSet;
                    });
                    if (!(intersect.length > 0)) {
                      continue;
                    }
                  } else {
                    intersect = step.sets.filter(function(skipSet) {
                      var hasSet, _j, _len1, _ref1;
                      _ref1 = s.sets;
                      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        hasSet = _ref1[_j];
                        if (hasSet === skipSet) {
                          return true;
                        }
                      }
                    });
                    if (!(intersect.length > 0)) {
                      continue;
                    }
                  }
                }
                if (s === step) {
                  s.fail = true;
                  update = 'run::step:failed';
                } else {
                  s.skip = true;
                  update = 'run::step:skipped';
                  skipped.push(s);
                }
                _this.deferral.notify({
                  update: update,
                  "class": _this.constructor.name,
                  jobUUID: _this.uuid,
                  progress: _this.progress(),
                  at: Date.now(),
                  error: error,
                  step: step,
                  originator: s === step
                });
              }
              return _this.notice.event('run::step:failed', {
                update: 'run::step:failed',
                "class": _this.constructor.name,
                jobUUID: _this.uuid,
                progress: _this.progress(),
                at: Date.now(),
                error: error,
                step: step,
                skipped: skipped
              }).then(done);
            },
            beforeEach: function(done, control) {
              var hasTimedOut, targetDefer, timeout;
              if (step.skip) {
                control.skip();
                done();
              }
              hasTimedOut = false;
              targetDefer = control.defer;
              if (!(step.type === 'leaf' || control.signature[0] === 'done')) {
                process.nextTick(function() {
                  return targetDefer.resolve();
                });
                done();
                return;
              }
              timeout = setTimeout((function() {
                hasTimedOut = true;
                return injectionConfig.onError(targetDefer.resolve, {}, new Error('timeout'));
              }), step.ref.timeout || 2000);
              control.args[0] = function() {
                clearTimeout(timeout);
                if (hasTimedOut) {
                  return;
                }
                return targetDefer.resolve();
              };
              done();
            },
            afterEach: function(done) {
              if (!(step.skip || step.fail)) {
                step.done = true;
                message = {
                  update: 'run::step:done',
                  "class": _this.constructor.name,
                  jobUUID: _this.uuid,
                  progress: _this.progress(),
                  at: Date.now(),
                  step: step
                };
                return _this.notice.event(message.update, message).then(function() {
                  _this.deferral.notify(message);
                  return done();
                });
              }
              return done();
            }
          };
          return inject.async(injectionConfig, step.ref.fn);
        })).then(function() {
          message = {
            update: 'run::complete',
            "class": _this.constructor.name,
            jobUUID: _this.uuid,
            progress: _this.progress(),
            at: Date.now()
          };
          return _this.notice.event(message.update, message).then(function() {
            _this.deferral.notify(message);
            return running.resolve({
              job: _this
            });
          });
        }, function(error) {
          return console.log('ERROR_IN_PHRASE_JOB', error.stack);
        }, function(notify) {});
      });
      return running.promise;
    };

    return Job;

  })();
};
