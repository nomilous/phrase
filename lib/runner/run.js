// Generated by CoffeeScript 1.6.3
var api, deferred, error, pipeline, _ref;

_ref = require('also'), deferred = _ref.deferred, pipeline = _ref.pipeline;

error = function(code, message) {
  return Object.defineProperty(new Error(message), 'code', {
    value: code
  });
};

api = {
  start: function(root, opts, params) {
    var context, notice, running, tree, uuid;
    if (opts == null) {
      opts = {};
    }
    if (params == null) {
      params = {};
    }
    context = root.context;
    tree = context.tree, notice = context.notice;
    uuid = opts.uuid;
    running = defer();
    process.nextTick(function() {
      if (uuid == null) {
        return running.reject(error(1, "missing opts.uuid"));
      }
      if (tree.vertices[uuid] == null) {
        return running.reject(error(2, "uuid: '" + uuid + "' not in local tree"));
      }
      return pipeline([
        function() {
          return api.getSteps(root, opts, running);
        }, function(steps) {
          var job;
          job = new context.Job({
            steps: steps,
            deferral: running,
            params: params
          });
          return job.run();
        }
      ]).then(function(result) {
        return running.resolve(result);
      }, function(error) {
        return running.reject(error);
      }, function(update) {
        return running.notify(update);
      });
    });
    return running.promise;
  },
  getSteps: deferred(function(getting, root, opts, running) {
    var afters, befores, context, count, depth, leaves, recurse, set, start, steps, tree, uuid;
    context = root.context;
    tree = context.tree;
    uuid = opts.uuid;
    leaves = tree.leavesOf(uuid);
    count = leaves.length;
    steps = [];
    befores = {};
    afters = {};
    set = 0;
    depth = 0;
    start = recurse = function() {
      var inbound, leaf, outbound, remaining, route;
      set++;
      remaining = leaves.length;
      if (remaining === 0) {
        steps = steps.filter(function(s) {
          return s != null;
        });
        running.notify({
          update: 'scan::complete',
          at: Date.now(),
          steps: steps.length,
          leaves: count
        });
        return getting.resolve(steps);
      }
      leaf = leaves.shift();
      route = tree.findRoute(null, leaf.uuid);
      outbound = [];
      inbound = route.map(function(uuid) {
        outbound.unshift(tree.vertices[uuid]);
        return tree.vertices[uuid];
      });
      inbound.map(function(phrase) {
        var beforeAll, beforeEach, position, _ref1;
        _ref1 = phrase.hooks, beforeAll = _ref1.beforeAll, beforeEach = _ref1.beforeEach;
        if (beforeAll != null) {
          if (befores[beforeAll.uuid] == null) {
            position = steps.push({
              sets: [],
              depth: depth,
              type: 'hook',
              ref: beforeAll
            }) - 1;
            befores[beforeAll.uuid] = position;
          }
          position = befores[beforeAll.uuid];
          steps[position].sets.push(set);
        }
        if (beforeEach != null) {
          steps.push({
            set: set,
            depth: depth,
            type: 'hook',
            ref: beforeEach
          });
        }
        return depth++;
      });
      steps.push({
        set: set,
        depth: depth,
        type: 'leaf',
        ref: leaf
      });
      outbound.map(function(phrase) {
        var afterAll, afterEach, oldPosition, position, pset, step, _i, _len, _ref1, _ref2;
        depth--;
        _ref1 = phrase.hooks, afterEach = _ref1.afterEach, afterAll = _ref1.afterAll;
        if (afterEach != null) {
          steps.push({
            set: set,
            depth: depth,
            type: 'hook',
            ref: afterEach
          });
        }
        if (afterAll != null) {
          step = {
            sets: [set],
            depth: depth,
            type: 'hook',
            ref: afterAll
          };
          position = steps.push(step) - 1;
          if (afters[afterAll.uuid] != null) {
            oldPosition = afters[afterAll.uuid];
            _ref2 = steps[oldPosition].sets;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              pset = _ref2[_i];
              step.sets.push(pset);
            }
            delete steps[oldPosition];
          }
          return afters[afterAll.uuid] = position;
        }
      });
      return recurse();
    };
    running.notify({
      update: 'scan::starting',
      at: Date.now()
    });
    return start();
  })
};

module.exports = api;
