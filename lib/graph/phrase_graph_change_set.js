// Generated by CoffeeScript 1.6.3
var defer, v1;

v1 = require('node-uuid').v1;

defer = require('when').defer;

exports.createClass = function(root) {
  var PhraseGraphChangeSet, changeSets;
  changeSets = {};
  PhraseGraphChangeSet = (function() {
    function PhraseGraphChangeSet(graphA, graphB) {
      var changes, newGraph, newUUID, newVertex, parentPath, path, runningGraph, runningUUID, runningVertex, uuid, vertex, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7;
      this.graphA = graphA;
      this.graphB = graphB;
      this.uuid = v1();
      this.changes = {
        uuid: this.uuid
      };
      changeSets[this.uuid] = this;
      runningGraph = this.graphA;
      newGraph = this.graphB;
      for (path in runningGraph.paths) {
        runningUUID = runningGraph.paths[path];
        runningVertex = runningGraph.vertices[runningUUID];
        newUUID = newGraph.paths[path];
        if (newUUID == null) {
          (_base = this.changes).deleted || (_base.deleted = {});
          this.changes.deleted[path] = runningVertex;
          continue;
        }
        newVertex = newGraph.vertices[newUUID];
        if (changes = runningVertex.getChanges(newVertex)) {
          if (changes.fn != null) {
            if (runningVertex.leaf) {
              (_base1 = this.changes).updated || (_base1.updated = {});
              (_base2 = this.changes.updated)[path] || (_base2[path] = {});
              this.changes.updated[path].fn = changes.fn;
            }
          }
          if (changes.timeout != null) {
            (_base3 = this.changes).updated || (_base3.updated = {});
            (_base4 = this.changes.updated)[path] || (_base4[path] = {});
            this.changes.updated[path].timeout = changes.timeout;
          }
          if (changes.hooks != null) {
            parentPath = path.split('/').slice(0, -2).join('/');
            (_base5 = this.changes).updated || (_base5.updated = {});
            (_base6 = this.changes.updated)[parentPath] || (_base6[parentPath] = {});
            this.changes.updated[parentPath].hooks = changes.hooks;
          }
        }
      }
      for (path in newGraph.paths) {
        if (runningGraph.paths[path] == null) {
          uuid = newGraph.paths[path];
          vertex = newGraph.vertices[uuid];
          (_base7 = this.changes).created || (_base7.created = {});
          this.changes.created[path] = vertex;
          continue;
        }
      }
    }

    PhraseGraphChangeSet.prototype.AtoB = function() {
      var doing, path;
      doing = defer();
      for (path in this.changes.updated) {
        this.graphA.vertices.update(this.changes.updated[path]);
      }
      process.nextTick(doing.resolve);
      return doing.promise;
    };

    return PhraseGraphChangeSet;

  })();
  return Object.defineProperty(PhraseGraphChangeSet, 'applyChanges', {
    enumarable: true,
    get: function() {
      return function(uuid, direction) {
        var changeSet;
        changeSet = changeSets[uuid];
        return changeSet[direction || 'AtoB']();
      };
    }
  });
};
