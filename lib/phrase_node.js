// Generated by CoffeeScript 1.6.3
var v1;

v1 = require('node-uuid').v1;

exports.createClass = function(root) {
  var PhraseNode;
  return PhraseNode = (function() {
    var PhraseHook, PhraseHooks, PhraseToken;

    PhraseToken = (function() {
      function PhraseToken(opts) {
        var localOpts, property, _fn, _i, _len, _ref,
          _this = this;
        if (opts == null) {
          opts = {};
        }
        localOpts = {};
        _ref = ['name', 'uuid'];
        _fn = function(property) {
          localOpts[property] = opts[property];
          return Object.defineProperty(_this, property, {
            get: function() {
              return localOpts[property];
            },
            enumerable: true
          });
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          property = _ref[_i];
          _fn(property);
        }
      }

      return PhraseToken;

    })();

    PhraseHook = (function() {
      function PhraseHook() {}

      return PhraseHook;

    })();

    PhraseHooks = (function() {
      function PhraseHooks(opts) {
        var localOpts, property, _fn, _i, _len, _ref,
          _this = this;
        if (opts == null) {
          opts = {};
        }
        localOpts = {};
        _ref = ['beforeAll', 'beforeEach', 'afterEach', 'afterAll'];
        _fn = function(property) {
          localOpts[property] = opts[property];
          return Object.defineProperty(_this, property, {
            get: function() {
              return localOpts[property];
            },
            enumerable: true
          });
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          property = _ref[_i];
          _fn(property);
        }
      }

      return PhraseHooks;

    })();

    function PhraseNode(opts) {
      var localOpts, property, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      localOpts = {
        uuid: opts.uuid || v1(),
        text: opts.text,
        leaf: opts.leaf,
        fn: opts.fn,
        timeout: opts.timeout || 2000,
        hooks: new PhraseHooks(opts.hooks),
        deferral: opts.deferral,
        queue: opts.queue
      };
      opts.token.uuid = localOpts.uuid;
      localOpts.token = new PhraseToken(opts.token);
      _ref = ['uuid', 'token', 'text'];
      _fn = function(property) {
        return Object.defineProperty(_this, property, {
          get: function() {
            return localOpts[property];
          },
          enumerable: true
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        _fn(property);
      }
      _ref1 = ['fn', 'timeout', 'hooks', 'deferral', 'queue'];
      _fn1 = function(property) {
        return Object.defineProperty(_this, property, {
          get: function() {
            return localOpts[property];
          },
          enumerable: false
        });
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        property = _ref1[_j];
        _fn1(property);
      }
      Object.defineProperty(this, 'leaf', {
        enumerable: true,
        get: function() {
          return localOpts.leaf;
        },
        set: function(value) {
          if (localOpts.leaf != null) {
            return;
          }
          return localOpts.leaf = value;
        }
      });
      Object.defineProperty(this, 'update', {
        enumerable: false,
        get: function() {
          return function(changes) {
            var thing, _k, _len2, _ref2, _results;
            _ref2 = ['fn', 'timeout'];
            _results = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              thing = _ref2[_k];
              if (changes[thing] != null) {
                _results.push(localOpts[thing] = changes[thing].to);
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
        }
      });
    }

    PhraseNode.prototype.getChanges = function(vertex) {
      var changes, currentFn, currentTimeout, hookType, latestFn, latestTimeout, property, _base, _base1, _i, _j, _len, _len1, _ref, _ref1;
      changes = void 0;
      _ref = ['fn', 'timeout'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        if (this[property].toString() !== vertex[property].toString()) {
          changes || (changes = {
            target: this
          });
          changes[property] = {
            from: this[property],
            to: vertex[property]
          };
        }
      }
      _ref1 = ['beforeAll', 'beforeEach', 'afterEach', 'afterAll'];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        hookType = _ref1[_j];
        currentFn = (function() {
          try {
            return this.hooks[hookType].fn.toString();
          } catch (_error) {}
        }).call(this);
        currentTimeout = (function() {
          try {
            return this.hooks[hookType].timeout;
          } catch (_error) {}
        }).call(this);
        latestFn = (function() {
          try {
            return vertex.hooks[hookType].fn.toString();
          } catch (_error) {}
        })();
        latestTimeout = (function() {
          try {
            return vertex.hooks[hookType].timeout;
          } catch (_error) {}
        })();
        if (currentFn !== latestFn) {
          changes || (changes = {
            target: this
          });
          changes.hooks || (changes.hooks = {});
          (_base = changes.hooks)[hookType] || (_base[hookType] = {});
          changes.hooks[hookType].fn = {
            from: (function() {
              try {
                return this.hooks[hookType].fn;
              } catch (_error) {}
            }).call(this),
            to: (function() {
              try {
                return vertex.hooks[hookType].fn;
              } catch (_error) {}
            })()
          };
        }
        if (currentTimeout !== latestTimeout) {
          changes || (changes = {
            target: this
          });
          changes.hooks || (changes.hooks = {});
          (_base1 = changes.hooks)[hookType] || (_base1[hookType] = {});
          changes.hooks[hookType].timeout = {
            from: (function() {
              try {
                return this.hooks[hookType].timeout;
              } catch (_error) {}
            }).call(this),
            to: (function() {
              try {
                return vertex.hooks[hookType].timeout;
              } catch (_error) {}
            })()
          };
        }
      }
      return changes;
    };

    return PhraseNode;

  })();
};
